# Operating System

## 链接

### 程序设计时

在这种情况下，我们将所有的源代码都放在一个文件中，例如 `main.cpp`：

```cpp
#include <iostream>

int add(int a, int b) {
    return a + b;
}

int main() {
    int a = 1, b = 2;
    std::cout << add(a, b) << std::endl;
    return 0;
}
```

在编译时，我们只需要编译这一个文件：

```sh
g++ main.cpp -o program
```

这样就生成了可执行文件 `program`，可以直接运行。在这种情况下，所有的代码都在一个文件中，编译器可以直接看到所有的代码，进行必要的优化，生成更高效的代码。

### 编译或汇编时

这种情况下，我们将程序拆分成多个源文件，并在编译或汇编时进行链接。例如，我们有两个源文件 `add.cpp` 和 `main.cpp`：

```cpp
// add.cpp
int add(int a, int b) {
    return a + b;
}
```

```cpp
// main.cpp
#include <iostream>

int add(int a, int b);

int main() {
    int a = 1, b = 2;
    std::cout << add(a, b) << std::endl;
    return 0;
}
```

在编译时，我们需要先将每个源文件编译成目标文件，然后再将它们链接在一起生成可执行文件。例如，我们可以这样编译和链接：

```sh
g++ -c add.cpp -o add.o
g++ -c main.cpp -o main.o
g++ add.o main.o -o program
```

这样也会生成可执行文件 `program`。在这种情况下，编译器只能看到单个源文件中的代码，无法对整个程序进行优化，因此可能会生成一些冗余的代码。但是，由于目标文件已经生成，后续的编译速度会更快。

### 加载时链接和运行时链接

加载时动态链接是指在可执行文件被加载到内存时，由系统动态链接器将可执行文件所依赖的共享库链接到进程的地址空间中。这样一来，可执行文件和共享库的代码和数据就可以在同一个地址空间中执行和访问。这种方式的优点是加载后不需要进行额外的链接操作，因此程序启动速度较快。缺点是如果共享库更新或者变更，需要重新编译和链接可执行文件。

运行时动态链接是指在程序运行过程中，通过调用动态链接库（也称为共享库）的API函数，将共享库链接到进程的地址空间中。这样一来，程序可以在运行时根据需要动态地加载和卸载共享库。这种方式的优点是程序的灵活性和可维护性较高，但是在程序启动时需要进行额外的链接操作，因此启动速度相对较慢。

在加载时动态链接中，程序在运行之前会链接所需要的 DLL 文件，并将 DLL 文件中的代码和数据加载到内存中。这种链接方式的好处是可以减小可执行文件的大小，同时多个程序可以共享同一个 DLL 文件，减少内存占用。缺点是如果所需的 DLL 文件不存在或者出现错误，程序将无法运行。

在运行时动态链接中，程序在运行时使用特定的函数动态链接到 DLL 文件中的代码和数据。这种链接方式的好处是可以在运行时根据需要加载 DLL 文件，灵活性更高。缺点是每次调用 DLL 中的函数都需要进行链接，会带来一定的性能开销。

![image.png](https://bu.dusays.com/2023/05/01/644fcb381cdf8.png)

## 记录型信号量

```cpp
S：信号量的值。当其值大于 0 时，表示可供使用的资源数；当其值小于 0 时，其绝对值表示等待使用该资源的进程数

/* P 操作的定义 */
P(S)
{
	S.value--;
	if (S.value < 0) 
	{
		// 将该进程加到 S.list 队列
		block();
	}
}

/* V 操作的定义 */
V(S)
{
	S.value++;
	if (S.value <= 0)
	{
		// 从 S.list 队列中将 Q 移走
		wakeup(Q);
	}
}
```

## 进程同步问题

### 生产者--消费者

假设有一个缓冲区，生产者往其中生产数据，消费者从其中取出数据。生产者和消费者各有若干个，它们之间需要通过缓冲区进行数据交换。

1. 初始化信号量：

* empty：计数信号量，初始值为N，表示缓冲区空闲的数量。
* full：计数信号量，初始值为0，表示缓冲区中已经存放的数据量。
* mutex：互斥信号量，初始值为1，用于保护缓冲区的互斥访问。

2. 生产者过程：

```scss
while (true) {
    produce(item);  // 生产数据
    P(empty);  // 等待空闲缓冲区
    P(mutex);  // 占用缓冲区
    put(item);  // 将数据放入缓冲区
    V(mutex);  // 释放缓冲区
    V(full);  // 增加缓冲区已有数据的数量
}

```

3. 消费者过程：

```scss
while (true) {
    P(full);  // 等待有数据的缓冲区
    P(mutex);  // 占用缓冲区
    item = get();  // 从缓冲区取出数据
    V(mutex);  // 释放缓冲区
    V(empty);  // 增加空闲缓冲区的数量
    consume(item);  // 消费数据
}
```

在这个过程中，P操作表示进程占用一个信号量资源，V操作表示进程释放一个信号量资源。对于互斥信号量mutex，每次只有一个进程可以占用资源，以保证缓冲区的互斥访问。对于计数信号量empty和full，它们都是等待队列，生产者和消费者通过占用和释放信号量来加入和离开等待队列。

### 理发师问题

#### 问题描述

一个理发店有一个理发师和若干个顾客。理发师可以理发，顾客可以等待理发或者离开。当顾客进入理发店时，如果理发师忙，顾客就等待。如果理发师闲着，顾客就可以马上得到理发。理发师理完一位顾客的头发后，会从等待区中选择一个顾客进行服务。

问题的关键在于如何使理发师和顾客之间进行合理的协作，避免死锁和饥饿的问题。

#### 解决办法

经典的解决方法是使用信号量机制实现同步。定义以下信号量：

* customers：计数信号量，初始值为0，表示等待理发的顾客数量。
* barber：互斥信号量，初始值为1，用于控制理发师的访问。
* mutex：互斥信号量，初始值为1，用于保护customers计数信号量的互斥访问。

理发师过程：

```scss
while (true) {
    P(customers);  // 等待有顾客到来
    P(mutex);  // 占用顾客数量计数信号量
    customer = dequeue();  // 从顾客队列中取出一个顾客
    V(mutex);  // 释放顾客数量计数信号量
    cut_hair(customer);  // 为顾客理发
    V(barber);  // 理发
```

顾客过程：

```scss
while (true) {
    P(mutex);  // 占用顾客数量计数信号量
    if (customers < chairs) {  // 如果有空椅子
        enqueue(customer);  // 排队等待理发
        V(customers);  // 增加等待的顾客数量
        V(mutex);  // 释放顾客数量计数信号量
        P(barber);  // 等待理发师空闲
        get_haircut(customer);  // 接受理发师的服务
    } else {  // 如果没有空椅子，离开
        V(mutex);  // 释放顾客数量计数信号量
        leave(customer);  // 离开理发店
    }
}
```

在这个过程中，P操作表示进程占用一个信号量资源，V操作表示进程释放一个信号量资源。对于互斥信号量barber和mutex，每次只有一个进程可以占用资源，以保证对理发师和顾客队列的互斥访问。对于计数信号量customers，它是一个等待队列，顾客通过占用和释放信号量来加入和离开等待队列，而理发师则通过占用和释放信号量来控制顾客的理发顺序。

### 读者--写者问题

#### 问题描述

* 多个读者和写者共享一个资源，读者可以同时读取该资源，但写者进行写操作时需要独占该资源；
* 写者优先级高于读者，即当有写者等待时，不允许新的读者访问资源，直到所有写者完成写操作；
* 读写操作的互斥性，即在同一时刻只允许一个读写操作进行。

#### 解决办法

* wmutex：计数信号量，初始值为1，用于保护写操作的互斥访问。
* rmutex：计数信号量，初始值为1，用于互斥访问 readcount。
* readcount：整型变量，初始值为0，表示读者计数器

写者：

```scss
while (true) {
    P(wmutex);        // 请求写访问权
    write_data();    // 写操作c++
    V(wmutex);        // 释放写访问权
}
```

读者：

```scss
while (true) {

  P(rmutex); // 保证对计数器的互斥访问
  readcount++; // 有一个读者进入临界区
  if (readcount == 1) { // 如果是第一个读者
    P(wmutex); // 请求写访问权，禁止写者同时写入
  }
  V(rmutex); // 释放对计数器的访问
  
  read_data(); // 读操作

  P(rmutex); // 保证对计数器的互斥访问
  readcount--; // 有一个读者离开临界区
  if (readers == 0) { // 如果是最后一个读者
    V(wmutex); // 释放写访问权
  }
  V(rmutex); // 释放对计数器的访问
}
```

### 哲学家就餐问题

#### 问题描述

在一个圆形餐桌上坐着N个哲学家，每个哲学家面前有一盘食物和一只叉子。这些哲学家只有在同时拿到自己面前的两个叉子时才能进食。每个哲学家都有两个邻居，因此有N个叉子。

问题的关键在于如何使哲学家能够避免死锁和饥饿地进食。

#### 解决办法

解决哲学家就餐问题的一种常见方法是使用资源分级和时间限制。以下是一种解决方案：

1. 给每个叉子都分配一个编号，从1到N。
2. 哲学家只有在同时拿到两个编号为i和(i+1)%N的叉子时才能吃饭。
3. 为了避免死锁，可以采用两种方法之一：
   * 方法一：将一个叉子的拿取和放下操作定义为原子性操作，采用信号量来实现同步。每个哲学家需要先尝试获取自己左右两个叉子的信号量，只有在同时获取到两个信号量时才能进食。在哲学家用完餐具后，释放这两个信号量，让其他哲学家能够使用这些餐具。
   * 方法二：引入一个“服务员”线程，服务员维护一个计数器，记录当前使用餐具的数量。当哲学家需要进餐时，需要向服务员发出请求。服务员检查当前使用餐具的数量是否已经达到了N-1，如果是，则等待一段时间再重新检查，直到有餐具被释放出来。如果不是，则服务员将餐具分配给该哲学家。哲学家用完餐具后，将餐具归还给服务员。

需要注意的是，无论是哪种方法，都需要遵循以下两个原则：

* 要确保每个哲学家都能获得进餐的机会，避免饥饿。
* 要确保所有哲学家都能进餐，而不会导致死锁。

### 图书馆阅览室问题

#### 问题描述

假定阅览室最多可同时容纳 100 个人阅读，读者进入时，必须在阅览室门口的一个登记表上登记，内容包括姓名、座号等，离开时要撤掉登记内容。用P、V操作描述读者进程的同步算法。

#### 解决办法

* count：计数信号量，初始值为100，代表阅览室的空闲座位数
* mutex：计数信号量，初始值为1，用于互斥访问登记表

```scss

while (true) {
	P(count);
	P(mutex);
	查登记表，置某座位为占用；
	V(mutex);
	......
	read();
	......
	P(mutex);
	查登记表，置某座位为空；
	V(mutex);
	V(count);
}
```
